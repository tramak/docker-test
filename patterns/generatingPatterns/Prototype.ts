interface Prototype<T> {
  create: () => T;
}

/**
 * Паттерн используется чтобы:
 *
 * 1. избежать дополнительных усилий по созданию объекта стандартным путём
 *   (
 *     имеется в виду использование конструктора,
 *     так как в этом случае также будут вызваны конструкторы всей иерархии предков объекта
 *   ),
 *   когда это непозволительно дорого для приложения.
 *   избежать наследования создателя объекта (object creator) в клиентском приложении, как это делает паттерн abstract factory.
 * 2 .Используйте этот шаблон проектирования, когда системe безразлично как именно в ней создаются,
 * компонуются и представляются продукты:
 *
 * 1. инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;
 * 2. избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;
 * 3. экземпляры класса могут находиться в одном из нескольких различных состояний.
 *   Может оказаться удобнее установить соответствующее число прототипов и клонировать их,
 *   а не инстанцировать каждый раз класс вручную в подходящем состоянии.
 */
class MyClass implements Prototype<MyClass> {
  private db?: string;
  private map = new Map();

  constructor();
  constructor(db: string)
  constructor(db?: string) {
    if (db) {
      this.setDb(db);
      this.init();
    }
  }

  protected setDb(db: string) {
    this.db = db;
  }

  init() {
    this.map.set('test', 10);
  }

  create() {
    const newInstance = new MyClass();
    if (this.db) {
      newInstance.setDb(this.db);
      newInstance.map = new Map(this.map);
    }

    return newInstance;
  }
}

const p1 = new MyClass('myTest1');

const p2 = p1.create();
console.log(p1);
console.log(p2);
